/**
 * SSA Subtitles parser
 */
(function(exports, NODE){
  
  //var NODE = ("object" == typeof exports);
  
  if (NODE) {
    
    var fs = require('fs')
      , readline = require('readline');
    
  } else {
    window.SSA = {};
    var exports = window.SSA;
  }


  exports.SECTION_REGEXP = new RegExp('^[\ufeff]?\\[([^\\]]+)\\]$');
  exports.PAIR_REGEXP    = new RegExp('^([^\\:]+): (.+)$');
  exports.COMMENT_REGEXP = new RegExp('^;\s*(.*)\s*$');

  exports.DEFAULT_EOL = '\r\n'
  exports.DEFAULT_OUTPUT_STREAM = null; // can be anything with a
                                        // `#write` method

  if (NODE) {
    exports.DEFAULT_OUTPUT_STREAM = process.stdout;
  } else {
    
    // Don't know if should be called "Buffer"
    var Buffer = function(){
      this.data = '';
    };
    
    Buffer.prototype = {
      write: function(data){
        this.data += data;
      },
      reset: function(){
        this.data = '';
      }
    };
    
    exports.Buffer = Buffer;
    exports.DEFAULT_OUTPUT_STREAM = new exports.Buffer();
  }


  /**
  * Parse a single line of SSA and return its information.
  * 
  * The returned object has 3 keys:
  * - line: the given line, as is.
  * - type: the type of the line (null if line couldn't be parsed)
  * - data: info related to the line (empty object if line couldn't be parsed)
  * 
  * The `data` object may have the following keys:
  * 
  * - { // if type == "comment" (e.g. "; Script generated by Aegisub 3.0.2")
  *      key: null
  *      value: the_comment
  *   }
  * 
  * - { // if type == "section" (e.g. "[Script Info]")
  *      name: name_of_the_section
  *   }
  * 
  * - { // if type == "pair" (e.g. "ScriptType: v4.00+")
  *      key: token_before_the_colon
  *      value: token_after_the_colon
  *   }
  * 
  * @param line
  * @return an object with information about the given line
  */
  function parseLine(line){
    
    line = line || '';  
    
    var result = {
        line: line
      , type: null
      , data: {}
    };
    
    var m;
    
    if ( m = line.match(exports.COMMENT_REGEXP) ) {
      result.type = 'comment';
      result.data = {
          key: null
        , value: m[1]
      };
    } else
      
    if ( m = line.match(exports.SECTION_REGEXP) ) {
      result.type = 'section';
      result.data = {
        name: m[1]
      };
    } else
      
    if ( m = line.match(exports.PAIR_REGEXP) ) {
      result.type = 'pair';
      result.data = {
          key: m[1]
        , value: m[2]
      };
    }
    
    return result;
  }


  /**
  * Key-Value pair.
  * 
  * Usage:
  * ======
  * 
  * x = new Item("foo", "bar, baz, Red, Green, Blue");
  * 
  * x.raw_value; // "bar, baz"
  * x.value;     // "bar, baz"
  * x.format;    // null
  * 
  * x.setFormat("a, b, colors");
  * x.format; // "a, b, colors"
  * 
  * x.raw_value; // "bar, baz"
  * x.value;     // ["bar", "baz", "Red, Green, Blue"]
  * 
  * // 
  * // When you #setFormat, the #get and #set methods may be used to update the
  * // info in an easier way.
  * //
  * 
  * x.get('a'); // "bar"
  * x.get('b'); // "baz"
  * x.get('colors'); // "Red, Green, Blue"
  * 
  * x.set('colors', 'Invisible Pink');
  * x.get('colors'); // "Invisible Pink"
  * 
  * x.value;     // ["bar", "baz", "Invisible Pink"]
  * x.raw_value; // "bar, baz, Invisible Pink"
  * 
  * @param key
  * @param value
  */
  function Item(key, value) {
    
    this.key = key;
    this.raw_value = value;
    
    // Whenever the format changes ...
    this.format = null;
    
    // ... `this.value` will be updated.
    this.value = value;
    
  }

  Item.prototype = {
    
      /**
      * Update the `value` field according to `format`.
      * 
      * @param format comma-separated tokens
      * @return nothing
      */
      setFormat: function(format){
        
        // Lines like "Format: foo, bar, baz" can't be formatted
        if ('Format' == this.key) {
          return;
        }
        
        this.format = format;
        
        var tokens = this.raw_value.split(',');
        
        var value;
        value = tokens.slice(0, format.length-1);
        value.push( tokens.slice(format.length-1).join(',') );
        
        this.value = value;
      }
      
      /**
      * @param key as given in the format
      * @return value associated to the given key
      */
    , get: function(key){
        if (!this.format) {
          return null;
        }
        
        var index = this.format.indexOf(key);
        if (index === -1) {
          return null;
        }
        
        return this.value[index];
      }
      
      /**
       * @param key
       * @param value
       * @return true if everything's OK, null otherwise
       */
    , set: function(key, value){
        if (!this.format) {
          return null;
        }
        
        var index = this.format.indexOf(key);
        if (index === -1) {
          return null;
        }
        
        this.value[index] = value;
        this.raw_value = this.value.join(',');
        return true;
      }
    
      /**
       * Copy the item (formatted, of course) to the given output stream.
       * 
       * @param out the output stream
       * @param EOL well, this string will be copied at the End Of each Line
       */
    , dump: function(out, EOL){
        out = out || exports.DEFAULT_OUTPUT_STREAM;
        EOL = EOL || exports.DEFAULT_EOL;
        
        out.write(this.key);
        out.write(': ');
        
        if (this.format) {
          out.write(this.value.join(','));
        } else {
          out.write(this.value);
        }
        
        out.write(EOL);
      }
  };

  /**
   * @param line like "Key: Value"
   * @return a new item
   */
  Item.fromLine = function(line){
    var r = parseLine(line);
    
    if ('pair' != r.type) {
      throw new Error('expected line of type "pair", not "'+r.type+'"');
    }
    
    return new Item(r.data.key, r.data.value);
  }


  function Section(name) {
    this.name = name;
    
    this.format = null;
    this.items = [];
  }
  Section.prototype = {

      addItem: function(key, value){
        var item = new Item(key, value);
        
        if ('Format' == key) {
          this.setFormat(value);
          
          var sectionFormat = this.format;
          this.items.forEach(function(item){
            item.setFormat(sectionFormat);
          });
        } else if (this.format) {
          item.setFormat(this.format);
        }
        
        this.items.push(item);
        return item;
      }
      
    , setFormat: function(formatString){
        var format = [];
        formatString.split(',').forEach(function(key){
          key = key.replace(/^\s+|\s+$/, ''); // remove trailing spaces
          format.push(key);
        });
        this.format = format;
        return format;
      }
    
      /**
       * Copy the section (formatted, of course) to the given output stream.
       * This will call #dump for every item of the section with the same
       * arguments given to this.
       * 
       * @param out the output stream
       * @param EOL well, this string will be copied at the End Of each Line
       */
    , dump: function(out, EOL){
        out = out || exports.DEFAULT_OUTPUT_STREAM;
        EOL = EOL || exports.DEFAULT_EOL;
        
        this.items.forEach(function(item){
          item.dump(out, EOL);
        });
        
        out.write(EOL);
      }
    
    , each: function(key, callback){
        this.items.forEach(function(item){
          if (key == item.key) {
            callback(item);
          }
        });
      }
  };


  function Container() {
    this.sections = [];
  }
  Container.prototype = {

      addSection: function(name){
        var section = new Section(name);
        this.sections.push(section);
        return section;
      }
    
    , section: function(name){
        var i = 0
          , section = null;
        
        while (i < this.sections.length && section == null) {
          if (name == this.sections[i].name) {
            section = this.sections[i];
          }
          
          i++;
        }
        
        return section;
      }
    
    , sectionNames: function(){
        var names = [];
        this.sections.forEach(function(section){
          names.push(section.name);
        });
        return names;
      }
    
      /**
       * Copy the container (formatted, of course) to the given output stream.
       * This will call #dump for every section, passing the same arguments
       * given to this.
       * 
       * @param out the output stream
       * @param EOL well, this string will be copied at the End Of each Line
       */
    , dump: function(out, EOL){
        out = out || exports.DEFAULT_OUTPUT_STREAM;
        EOL = EOL || exports.DEFAULT_EOL;
        
        var firstSection = true;
        
        this.sections.forEach(function(section){
          if (firstSection) {
            out.write('\ufeff');
            firstSection = false;
          }
          out.write('['+section.name+']' + EOL);
          section.dump(out, EOL);
        });
      }
  };


  /**
  * @param path to the file
  * @param callback
  */
  function parseFile(path, callback){

    if ('string' != typeof path) {
      throw new Error('first argument must be of type string');
    }
    
    if ('function' != typeof callback) {
      throw new Error('second argument must be a callback');
    }
    
    var rs = fs.createReadStream(path, {encoding: 'utf-8'});
    var container = new Container();
    
    // Is it OK to use readline for this?
    var rl = readline.createInterface({
      input: rs,
      output: process.stdout,
      terminal: false
    });
    
    rl.on('line', function(line){
    
      var r = parseLine(line);
      
      var currentSection = container.sections[ container.sections.length-1 ];
      
      switch (r.type) {
        case 'section':
          container.addSection(r.data.name);
          break;
        case 'pair':
          currentSection.addItem(r.data.key, r.data.value);
          break;
      }
        
    }).on('close', function(){
      callback(null, container);
    });
  }


  if (NODE) {
    exports.parseFile = parseFile;
  }

  exports.parseLine = parseLine;
  exports.Container = Container;
  exports.Section = Section;
  exports.Item = Item;

})(
  ("object" == typeof exports ? exports : window),
  "object" == typeof exports
);